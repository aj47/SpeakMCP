/**
 * Google A2A (Agent-to-Agent Protocol) Types
 * 
 * Based on the A2A Protocol Specification (DRAFT v1.0)
 * https://a2a-protocol.org/latest/specification/
 * 
 * A2A is designed for agent-to-agent communication and task delegation,
 * complementing the ACP (Agent Client Protocol) which handles user-to-agent interaction.
 */

// =============================================================================
// Task State and Lifecycle
// =============================================================================

/**
 * Task states per A2A spec.
 * These align with the A2A protocol's task lifecycle.
 */
export type A2ATaskState =
  | 'submitted'      // Task created, not yet started
  | 'working'        // Agent is actively processing
  | 'input-required' // Waiting for user input (human-in-the-loop)
  | 'completed'      // Successfully finished
  | 'failed'         // Error occurred
  | 'canceled'       // User or system canceled
  | 'rejected'       // Agent refused to process
  | 'unknown';       // Unknown state (fallback)

/**
 * Task status with state, message, and optional error details.
 */
export interface A2ATaskStatus {
  /** Current state of the task */
  state: A2ATaskState;
  /** Optional message providing context about the current state */
  message?: A2AMessage;
  /** ISO 8601 timestamp of the status update */
  timestamp: string;
}

/**
 * The fundamental unit of work in A2A.
 * Tasks are stateful and progress through a defined lifecycle.
 */
export interface A2ATask {
  /** Unique identifier for this task (format: tasks/{task_id}) */
  id: string;
  /** Optional context ID for grouping related tasks */
  contextId?: string;
  /** Current status of the task */
  status: A2ATaskStatus;
  /** Output artifacts generated by the task */
  artifacts?: A2AArtifact[];
  /** Conversation history for this task */
  history?: A2AMessage[];
  /** Additional metadata about the task */
  metadata?: Record<string, unknown>;
}

// =============================================================================
// Messages and Parts
// =============================================================================

/**
 * Role of the message sender.
 */
export type A2AMessageRole = 'user' | 'agent';

/**
 * A communication turn between client and agent.
 */
export interface A2AMessage {
  /** Role of the message sender */
  role: A2AMessageRole;
  /** Content parts of the message */
  parts: A2APart[];
  /** Optional message metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Text content part.
 */
export interface A2ATextPart {
  text: string;
}

/**
 * File content part.
 */
export interface A2AFilePart {
  file: {
    /** MIME type of the file */
    mediaType: string;
    /** Optional file name */
    name?: string;
    /** Base64-encoded file content */
    fileWithBytes?: string;
    /** URI reference to the file */
    fileWithUri?: string;
  };
}

/**
 * Structured data part.
 */
export interface A2ADataPart {
  data: {
    /** Arbitrary structured data */
    data: Record<string, unknown>;
  };
}

/**
 * Union type for message parts.
 * Per A2A v1.0, the member name itself acts as the type discriminator.
 */
export type A2APart = A2ATextPart | A2AFilePart | A2ADataPart;

// =============================================================================
// Artifacts
// =============================================================================

/**
 * Output generated by an agent as a result of a task.
 */
export interface A2AArtifact {
  /** Unique identifier for this artifact within the task */
  artifactId: string;
  /** Human-readable name for the artifact */
  name?: string;
  /** Description of the artifact */
  description?: string;
  /** Content parts of the artifact */
  parts: A2APart[];
  /** Artifact metadata */
  metadata?: Record<string, unknown>;
  /** Index for ordering multiple artifacts */
  index?: number;
  /** Whether this is the final chunk (for streaming) */
  lastChunk?: boolean;
  /** Whether to append to existing artifact (for streaming) */
  append?: boolean;
}

// =============================================================================
// Agent Card (Discovery)
// =============================================================================

/**
 * Skill offered by an A2A agent.
 */
export interface A2ASkill {
  /** Unique identifier for the skill */
  id: string;
  /** Human-readable name */
  name: string;
  /** Description of what the skill does */
  description?: string;
  /** Tags/categories for the skill */
  tags?: string[];
  /** Example prompts or inputs */
  examples?: string[];
  /** JSON Schema for skill input */
  inputSchema?: Record<string, unknown>;
  /** JSON Schema for skill output */
  outputSchema?: Record<string, unknown>;
}

/**
 * Authentication configuration for an agent.
 */
export interface A2AAuthConfig {
  /** Authentication schemes supported (e.g., "bearer", "oauth2", "apiKey") */
  schemes: string[];
  /** Credentials or configuration per scheme */
  credentials?: Record<string, unknown>;
}

/**
 * Capabilities declared by an A2A agent.
 */
export interface A2AAgentCapabilities {
  /** Whether the agent supports streaming responses */
  streaming?: boolean;
  /** Whether the agent supports push notifications via webhooks */
  pushNotifications?: boolean;
  /** Whether the agent supports task state history */
  stateHistory?: boolean;
  /** Supported input content types */
  inputModes?: string[];
  /** Supported output content types */
  outputModes?: string[];
}

/**
 * AgentCard - JSON metadata document describing an A2A Server.
 * Typically accessible at /.well-known/agent-card.json
 */
export interface A2AAgentCard {
  /** Agent's name */
  name: string;
  /** Human-readable description */
  description: string;
  /** URL of the A2A service endpoint */
  url: string;
  /** Protocol version supported (e.g., "1.0") */
  protocolVersion: string;
  /** Skills offered by this agent */
  skills: A2ASkill[];
  /** Supported capabilities */
  capabilities?: A2AAgentCapabilities;
  /** Default input content types */
  defaultInputModes?: string[];
  /** Default output content types */
  defaultOutputModes?: string[];
  /** Authentication requirements */
  authentication?: A2AAuthConfig;
  /** Additional metadata */
  metadata?: Record<string, unknown>;
  /** Agent's icon URL */
  iconUrl?: string;
  /** Agent's documentation URL */
  documentationUrl?: string;
  /** Contact information */
  provider?: {
    organization?: string;
    url?: string;
    email?: string;
  };
}

// =============================================================================
// Requests and Responses
// =============================================================================

/**
 * Configuration for a send message request.
 */
export interface A2ASendMessageConfig {
  /** Optional context ID to group related tasks */
  contextId?: string;
  /** Whether to accept partial/streaming responses */
  acceptedOutputModes?: string[];
  /** Timeout in milliseconds */
  timeoutMs?: number;
  /** Extensions to enable for this request */
  extensions?: string[];
  /** Whether to include history in the response */
  historyLength?: number;
  /** Custom metadata for the request */
  metadata?: Record<string, unknown>;
}

/**
 * Request to send a message to an A2A agent.
 */
export interface A2ASendMessageRequest {
  /** The message to send */
  message: A2AMessage;
  /** Optional configuration */
  configuration?: A2ASendMessageConfig;
  /** Optional task ID to continue an existing task */
  taskId?: string;
}

/**
 * Response from a send message request.
 * May return either a Task (for async processing) or a direct Message.
 */
export type A2ASendMessageResponse =
  | { task: A2ATask }
  | { message: A2AMessage };

// =============================================================================
// Streaming Events
// =============================================================================

/**
 * Task status update event for streaming.
 */
export interface A2ATaskStatusUpdateEvent {
  statusUpdate: {
    /** Task ID this update belongs to */
    taskId: string;
    /** Updated status */
    status: A2ATaskStatus;
    /** Whether this is the final update */
    final?: boolean;
  };
}

/**
 * Task artifact update event for streaming.
 */
export interface A2ATaskArtifactUpdateEvent {
  artifactUpdate: {
    /** Task ID this update belongs to */
    taskId: string;
    /** The artifact being updated */
    artifact: A2AArtifact;
  };
}

/**
 * Union type for stream events.
 */
export type A2AStreamEvent =
  | { task: A2ATask }
  | { message: A2AMessage }
  | A2ATaskStatusUpdateEvent
  | A2ATaskArtifactUpdateEvent;

// =============================================================================
// Push Notifications
// =============================================================================

/**
 * Push notification configuration for a task.
 */
export interface A2APushNotificationConfig {
  /** Unique ID for this configuration */
  id: string;
  /** Webhook URL to receive notifications */
  url: string;
  /** Optional token for webhook authentication */
  token?: string;
  /** Task states to trigger notifications */
  events?: A2ATaskState[];
  /** Additional headers to include in webhook requests */
  headers?: Record<string, string>;
}

// =============================================================================
// Error Types
// =============================================================================

/**
 * A2A protocol error codes.
 */
export type A2AErrorCode =
  | 'TASK_NOT_FOUND'
  | 'CONTENT_TYPE_NOT_SUPPORTED'
  | 'UNSUPPORTED_OPERATION'
  | 'TASK_NOT_CANCELABLE'
  | 'PUSH_NOTIFICATION_NOT_SUPPORTED'
  | 'INVALID_REQUEST'
  | 'INTERNAL_ERROR'
  | 'AUTHENTICATION_REQUIRED'
  | 'AUTHORIZATION_FAILED';

/**
 * A2A protocol error.
 */
export interface A2AError {
  /** Error code */
  code: A2AErrorCode;
  /** Human-readable error message */
  message: string;
  /** Additional error details */
  data?: unknown;
}

// =============================================================================
// Mapping Types (ACP <-> A2A)
// =============================================================================

/**
 * Mapping from ACP types to A2A types.
 * This helps with gradual migration.
 */
export const ACPToA2AStateMap: Record<string, A2ATaskState> = {
  pending: 'submitted',
  running: 'working',
  completed: 'completed',
  failed: 'failed',
  cancelled: 'canceled',
};

/**
 * Mapping from A2A types to ACP types.
 * This helps with backward compatibility.
 */
export const A2AToACPStateMap: Record<A2ATaskState, string> = {
  submitted: 'pending',
  working: 'running',
  'input-required': 'running',
  completed: 'completed',
  failed: 'failed',
  canceled: 'cancelled',
  rejected: 'failed',
  unknown: 'pending',
};

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Check if a task is in a terminal state.
 */
export function isTerminalState(state: A2ATaskState): boolean {
  return ['completed', 'failed', 'canceled', 'rejected'].includes(state);
}

/**
 * Check if a task is in a working state.
 */
export function isWorkingState(state: A2ATaskState): boolean {
  return ['submitted', 'working', 'input-required'].includes(state);
}

/**
 * Create a text part.
 */
export function textPart(text: string): A2ATextPart {
  return { text };
}

/**
 * Create a file part with bytes.
 */
export function filePart(
  mediaType: string,
  content: string,
  name?: string
): A2AFilePart {
  return {
    file: {
      mediaType,
      name,
      fileWithBytes: content,
    },
  };
}

/**
 * Create a file part with URI.
 */
export function filePartUri(
  mediaType: string,
  uri: string,
  name?: string
): A2AFilePart {
  return {
    file: {
      mediaType,
      name,
      fileWithUri: uri,
    },
  };
}

/**
 * Create a data part.
 */
export function dataPart(data: Record<string, unknown>): A2ADataPart {
  return {
    data: { data },
  };
}

/**
 * Create a simple text message.
 */
export function textMessage(role: A2AMessageRole, text: string): A2AMessage {
  return {
    role,
    parts: [textPart(text)],
  };
}

/**
 * Extract text from message parts.
 */
export function extractText(message: A2AMessage): string {
  return message.parts
    .filter((p): p is A2ATextPart => 'text' in p)
    .map(p => p.text)
    .join('\n');
}

/**
 * Convert ACP state to A2A state.
 */
export function acpStateToA2A(acpState: string): A2ATaskState {
  return ACPToA2AStateMap[acpState] || 'unknown';
}

/**
 * Convert A2A state to ACP state.
 */
export function a2aStateToACP(a2aState: A2ATaskState): string {
  return A2AToACPStateMap[a2aState] || 'pending';
}

/**
 * Generate a new task ID.
 */
export function generateTaskId(): string {
  const random = Math.random().toString(36).substring(2, 10);
  return `tasks/${Date.now()}_${random}`;
}

/**
 * Generate a new context ID.
 */
export function generateContextId(): string {
  const random = Math.random().toString(36).substring(2, 10);
  return `ctx_${Date.now()}_${random}`;
}
